stages:          # List of stages for jobs, and their order of execution
  - build
  - test
  - deploy
  - post-deploy
  - schedules

variables:
  DEFAULT_IMG: "registry.gitlab.mvajhi.ir/mvajhi/img-builder/runner"
  IMG_PATH: "${CI_REGISTRY}/${CI_PROJECT_NAMESPACE}/${CI_PROJECT_NAME}"
  MAIN_DOMAIN: "mvajhi.ir"
  SSH_USER: "ubuntu"
  BACKUP_PATH: "/opt/BACKUP"

.build-default:
  image: docker:dind
  retry: 2
  before_script:
    - echo "Login to docker reg..."
    - echo "$CI_REGISTRY_PASSWORD" | docker login $CI_REGISTRY -u $CI_REGISTRY_USER --password-stdin
    - echo "Login successful"
  rules:
    - if: '$CI_PIPELINE_SOURCE != "schedule"'

.test-default:
  image: docker:dind
  before_script:
    - echo "Login to docker reg..."
    - echo "$CI_REGISTRY_PASSWORD" | docker login $CI_REGISTRY -u $CI_REGISTRY_USER --password-stdin
    - echo "Login successful"
  rules:
    - if: '$CI_PIPELINE_SOURCE != "schedule"'

.trivy-default:
  image:
    name: aquasec/trivy:latest
    entrypoint: [""]
  variables:
    GIT_STRATEGY: none
    TRIVY_USERNAME: "$CI_REGISTRY_USER"
    TRIVY_PASSWORD: "$CI_REGISTRY_PASSWORD"
    TRIVY_AUTH_URL: "$CI_REGISTRY"
    FULL_IMAGE_NAME: "${IMG_PATH}/vote:${CI_COMMIT_SHORT_SHA}"
  script:
    - trivy image --exit-code 0 --cache-dir .trivycache/ --no-progress --format template --template "@/contrib/gitlab.tpl" --output "$CI_PROJECT_DIR/gl-container-scanning-report.json" "$FULL_IMAGE_NAME"
    - trivy image --exit-code 0 --cache-dir .trivycache/ --no-progress "$FULL_IMAGE_NAME"
    - trivy image --exit-code 1 --cache-dir .trivycache/ --severity CRITICAL --no-progress "$FULL_IMAGE_NAME"
  cache:
    paths:
      - /cache/.trivycache/
  artifacts:
    reports:
      container_scanning: gl-container-scanning-report.json
  allow_failure: true
  rules:
    - if: '$CI_PIPELINE_SOURCE != "schedule"'

build-vote-img:
  stage: build
  extends: .build-default
  script:
    - echo "Building img..."
    - docker build -t ${IMG_PATH}/vote:${CI_COMMIT_SHORT_SHA} ./vote
    - docker push ${IMG_PATH}/vote:${CI_COMMIT_SHORT_SHA}
    - echo "Building img complete."

build-result-img:
  stage: build
  extends: .build-default
  script:
    - echo "Building img..."
    - docker build -t ${IMG_PATH}/result:${CI_COMMIT_SHORT_SHA} ./result
    - docker push ${IMG_PATH}/result:${CI_COMMIT_SHORT_SHA}
    - echo "Building img complete."

build-worker-img:
  stage: build
  extends: .build-default
  script:
    - echo "Building img..."
    - docker build -t ${IMG_PATH}/worker:${CI_COMMIT_SHORT_SHA} ./worker
    - docker push ${IMG_PATH}/worker:${CI_COMMIT_SHORT_SHA}
    - echo "Building img complete."

build-load-img:
  stage: build
  extends: .build-default
  script:
    - echo "Building img..."
    - docker build -t ${IMG_PATH}/load:latest ./devops/seed-data
    - docker push ${IMG_PATH}/load:latest
    - echo "Building img complete."
  rules:
    - if: '$CI_PIPELINE_SOURCE != "schedule"'
      changes:
        - devops/seed-data/**

test-vote-img:
  stage: test
  extends: .test-default
  needs:
    - build-vote-img
  variables:
    IMG: "vote"
  script:
    - echo "Pulling image for test ${IMG}..."
    - docker pull "${IMG_PATH}/${IMG}:${CI_COMMIT_SHORT_SHA}"
    - echo "Testing image ${IMG}..."
    - sleep 5
    - echo "All tests pass for ${IMG}"

test-result-img:
  stage: test
  extends: .test-default
  needs:
    - build-result-img
  variables:
    IMG: "result"
  script:
    - echo "Pulling image for test ${IMG}..."
    - docker pull "${IMG_PATH}/${IMG}:${CI_COMMIT_SHORT_SHA}"
    - echo "Testing image ${IMG}..."
    - sleep 5
    - echo "All tests pass for ${IMG}"

test-worker-img:
  stage: test
  extends: .test-default
  needs:
    - build-worker-img
  variables:
    IMG: "worker"
  script:
    - echo "Pulling image for test ${IMG}..."
    - docker pull "${IMG_PATH}/${IMG}:${CI_COMMIT_SHORT_SHA}"
    - echo "Testing image ${IMG}..."
    - sleep 5
    - echo "All tests pass for ${IMG}"

# scan-vote-img:
#   stage: test
#   extends: .trivy-default
#   needs: 
#     - "test-vote-img"
#   variables:
#     IMAGE: ${IMAGE_PATH}/vote:${CI_COMMIT_SHORT_SHA}
    
# scan-result-img:
#   stage: test
#   extends: .trivy-default
#   needs: 
#     - "test-result-img"
#   variables:
#     IMAGE: ${IMAGE_PATH}/result:${CI_COMMIT_SHORT_SHA}

# scan-worker-img:
#   stage: test
#   extends: .trivy-default
#   needs: 
#     - "test-worker-img"
#   variables:
#     IMAGE: ${IMAGE_PATH}/worker:${CI_COMMIT_SHORT_SHA}


deploy-develop:
  stage: deploy
  image: $DEFAULT_IMG:tools
  variables:
    D_ADDR: mono.develop.${MAIN_DOMAIN}
    SERVER_NAME: develop-server
    R_URL: ${IMG_PATH}
    PIPELINE_ID: ${CI_COMMIT_SHORT_SHA}
    DEPLOY_PATH: "/opt/compose/voting-app"
  before_script:
    - echo "Set ssh key..."
    - chmod 400 $SSH_P_KEY
    - eval $(ssh-agent -s)
    - ssh-add $SSH_P_KEY
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
  script:
    - echo "Set env file..."
    - sed -e "s|D_ADDR|${D_ADDR}|g" -e "s|SERVER_NAME|${SERVER_NAME}|g" -e "s|R_URL|${R_URL}|g" -e "s|PIPELINE_ID|${PIPELINE_ID}|g" .env | tee .env.deploy
    - echo "Copy files to server..."
    - ssh -o StrictHostKeyChecking=no $SSH_USER@$D_ADDR "sudo [ -d $DEPLOY_PATH ] || sudo mkdir -p $DEPLOY_PATH && sudo chown $SSH_USER $DEPLOY_PATH"
    - scp -o StrictHostKeyChecking=no .env.deploy $SSH_USER@$D_ADDR:$DEPLOY_PATH/.env
    - scp -o StrictHostKeyChecking=no docker-compose.yml $SSH_USER@$D_ADDR:$DEPLOY_PATH/docker-compose.yml
    - echo "Deploying to server..."
    - |
      ssh -o StrictHostKeyChecking=no $SSH_USER@$D_ADDR "
      echo "$CI_REGISTRY_PASSWORD" | docker login $CI_REGISTRY -u $CI_REGISTRY_USER --password-stdin
      cd ${DEPLOY_PATH}
      docker compose up -d
      "
  
  environment:
    name: develop
    url: https://vote.mono.develop.${MAIN_DOMAIN}
  rules:
    - if: '$CI_PIPELINE_SOURCE != "schedule"'

post-deploy-load-test-develop:
  needs:
    - deploy-develop
  stage: post-deploy
  image: docker:dind
  variables:
    DOMAIN: mono.develop.${MAIN_DOMAIN}
    HOSTNAME: develop
    DOCKER_RUN: docker run -id --name loadtest-${HOSTNAME} ${IMG_PATH}/load:latest bash
    DOCKER_EXEC: docker exec -i loadtest-${HOSTNAME}
  before_script:
    - echo "Login to docker reg..."
    - echo "$CI_REGISTRY_PASSWORD" | docker login $CI_REGISTRY -u $CI_REGISTRY_USER --password-stdin
    - echo "Login successful"
  script:
    - ${DOCKER_RUN}
    - ${DOCKER_EXEC} python make-data.py
    - ${DOCKER_EXEC} ab -n 100 -c 50 -p posta -T "application/x-www-form-urlencoded" https://vote.${DOMAIN}/ 
    - ${DOCKER_EXEC} ab -n 1000 -c 50 -p postb -T "application/x-www-form-urlencoded" https://vote.${DOMAIN}/
  after_script:
    - docker rm -f loadtest-${HOSTNAME}
  rules:
    - if: '$CI_PIPELINE_SOURCE != "schedule"'

# from dev cert
postgres-create-backup:
  stage: schedules
  image: $DEFAULT_IMG:tools
  variables:
    D_ADDR: mono.develop.${MAIN_DOMAIN}
  before_script:
    - echo "Set ssh key..."
    - chmod 400 $SSH_P_KEY
    - eval $(ssh-agent -s)
    - ssh-add $SSH_P_KEY
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
  script:
    - |
      ssh -o StrictHostKeyChecking=no ${SSH_USER}@${D_ADDR} "
      # Create directory if not exist
      sudo [ -d ${BACKUP_PATH} ] || sudo mkdir -p ${BACKUP_PATH} && sudo chown ubuntu ${BACKUP_PATH}
      cd ${BACKUP_PATH}

      # Create postgresql backup
      docker exec -i -e PGPASSWORD=${POSTGRES_PASSWORD} postgresql-develop-server /usr/local/bin/pg_dumpall --host=localhost --port=5432 --username=${POSTGRES_USER} | gzip -9 > postgres_backup_${CI_PIPELINE_ID}.sql.gz
      "
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"

postgres-check-backup:
  stage: schedules
  image: $DEFAULT_IMG:toolsd
  needs: ["postgres-create-backup"]
  variables:
    D_ADDR: mono.develop.${MAIN_DOMAIN}
    POSTGRES_USER: ${POSTGRES_USER}
    POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
  before_script:
    - echo "Set ssh key..."
    - chmod 400 $SSH_P_KEY
    - eval $(ssh-agent -s)
    - ssh-add $SSH_P_KEY
    - mkdir -p ~/.ssh
    - chmod 700 ~/.ssh
  script:
    - scp -o StrictHostKeyChecking=no ${SSH_USER}@${D_ADDR}:${BACKUP_PATH}/postgres_backup_${CI_PIPELINE_ID}.sql.gz .
    - gunzip postgres_backup_${CI_PIPELINE_ID}.sql.gz
    - cp -r ./devops/psql-test psql-test
    - cp postgres_backup_${CI_PIPELINE_ID}.sql psql-test
    - docker run -d --name psql-test -e POSTGRES_USER=${POSTGRES_USER} -e POSTGRES_PASSWORD=${POSTGRES_PASSWORD} postgres:15-alpine
    - docker cp psql-test psql-test:/opt
    - sleep 10
    - cat psql-test/psql-test.sh | docker exec -i psql-test bash
    - docker cp psql-test:/opt/psql-test/restore.log .
  artifacts:
    paths:
    - ./restore.log
    expire_in: 1 week
  after_script:
    - docker rm -f psql-test
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"